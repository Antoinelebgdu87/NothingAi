// Syst√®me de license corrig√© - Fonctionne garantit
interface CustomLicense {
  key: string;
  createdAt: Date;
  expiresAt: Date;
  maxUsages: number;
  currentUsages: number;
  isActive: boolean;
}

class InstantLicenseManager {
  private userLicenseKey = "nothingai_license_instant";
  private licensesKey = "nothingai_custom_licenses";

  // Cl√©s de base qui marchent TOUJOURS
  private baseLicenses: CustomLicense[] = [
    {
      key: "NOTHINGAI-4C24HUEQ",
      createdAt: new Date("2024-01-01"),
      expiresAt: new Date("2030-12-31"),
      maxUsages: 999999,
      currentUsages: 0,
      isActive: true,
    },
    {
      key: "NOTHINGAI-TEST1234",
      createdAt: new Date("2024-01-01"),
      expiresAt: new Date("2030-12-31"),
      maxUsages: 999999,
      currentUsages: 0,
      isActive: true,
    },
    {
      key: "NOTHINGAI-DEMO5678",
      createdAt: new Date("2024-01-01"),
      expiresAt: new Date("2030-12-31"),
      maxUsages: 999999,
      currentUsages: 0,
      isActive: true,
    },
    {
      key: "NOTHINGAI-FREE0000",
      createdAt: new Date("2024-01-01"),
      expiresAt: new Date("2030-12-31"),
      maxUsages: 999999,
      currentUsages: 0,
      isActive: true,
    },
  ];

  // Obtenir toutes les licenses (base + personnalis√©es)
  private getAllAvailableLicenses(): CustomLicense[] {
    const customLicenses = this.getCustomLicenses();
    return [...this.baseLicenses, ...customLicenses];
  }

  // Obtenir les licenses personnalis√©es seulement
  private getCustomLicenses(): CustomLicense[] {
    try {
      const stored = localStorage.getItem(this.licensesKey);
      if (!stored) return [];

      const parsed = JSON.parse(stored);
      // Convertir les dates string en objets Date
      return parsed.map((license: any) => ({
        ...license,
        createdAt: new Date(license.createdAt),
        expiresAt: new Date(license.expiresAt),
      }));
    } catch (error) {
      console.warn("‚ö†Ô∏è Erreur lecture licenses:", error);
      return [];
    }
  }

  // Sauvegarder les licenses personnalis√©es
  private saveCustomLicenses(licenses: CustomLicense[]): void {
    try {
      localStorage.setItem(this.licensesKey, JSON.stringify(licenses));
      console.log("üíæ Licenses sauvegard√©es:", licenses.length);
    } catch (error) {
      console.warn("‚ö†Ô∏è Erreur sauvegarde licenses:", error);
    }
  }

  // Cr√©er une nouvelle license avec dur√©e et usages personnalis√©s
  public createCustomLicense(
    durationDays: number,
    maxUsages: number,
  ): { success: boolean; key: string; message: string } {
    try {
      // G√©n√©rer une cl√© unique
      const randomCode = Math.random().toString(36).substr(2, 8).toUpperCase();
      const licenseKey = `NOTHINGAI-${randomCode}`;

      // Calculer les dates
      const createdAt = new Date();
      const expiresAt = new Date(
        createdAt.getTime() + durationDays * 24 * 60 * 60 * 1000,
      );

      // Cr√©er la license
      const newLicense: CustomLicense = {
        key: licenseKey,
        createdAt,
        expiresAt,
        maxUsages,
        currentUsages: 0,
        isActive: true,
      };

      // Sauvegarder dans les licenses personnalis√©es
      const customLicenses = this.getCustomLicenses();
      customLicenses.push(newLicense);
      this.saveCustomLicenses(customLicenses);

      console.log("üÜï License cr√©√©e:", {
        key: licenseKey,
        duration: durationDays,
        maxUsages,
        expiresAt: expiresAt.toLocaleDateString(),
      });

      return {
        success: true,
        key: licenseKey,
        message: `License cr√©√©e: ${durationDays} jours, ${maxUsages} usages`,
      };
    } catch (error) {
      console.error("‚ùå Erreur cr√©ation license:", error);
      return {
        success: false,
        key: "",
        message: "Erreur lors de la cr√©ation",
      };
    }
  }

  // V√©rifier si une cl√© est valide (CORRIG√â)
  public isValidLicense(licenseKey: string): boolean {
    if (!licenseKey || typeof licenseKey !== "string") {
      console.log("‚ùå Cl√© invalide (vide ou mauvais type)");
      return false;
    }

    let cleanKey = licenseKey.trim().toUpperCase();

    // Normaliser le format : si pas de NOTHINGAI- au d√©but, l'ajouter
    if (!cleanKey.startsWith("NOTHINGAI-")) {
      if (cleanKey.startsWith("NOTHINGAI")) {
        cleanKey = cleanKey.replace("NOTHINGAI", "NOTHINGAI-");
      } else {
        cleanKey = `NOTHINGAI-${cleanKey}`;
      }
    }

    console.log("üîç V√©rification cl√©:", cleanKey);

    // Chercher dans toutes les licenses disponibles
    const allLicenses = this.getAllAvailableLicenses();
    const license = allLicenses.find((l) => l.key === cleanKey);

    if (!license) {
      console.log("‚ùå Cl√© non trouv√©e dans la base:", cleanKey);
      console.log(
        "üìã Cl√©s disponibles:",
        allLicenses.map((l) => l.key),
      );
      return false;
    }

    // V√©rifier l'expiration
    const now = new Date();
    const expiresAt = new Date(license.expiresAt);
    if (now > expiresAt) {
      console.log("‚ùå Cl√© expir√©e:", cleanKey, "Expire le:", expiresAt);
      return false;
    }

    // V√©rifier les usages
    if (license.currentUsages >= license.maxUsages) {
      console.log(
        "‚ùå Cl√© √©puis√©e:",
        cleanKey,
        `${license.currentUsages}/${license.maxUsages}`,
      );
      return false;
    }

    // V√©rifier si active
    if (!license.isActive) {
      console.log("‚ùå Cl√© d√©sactiv√©e:", cleanKey);
      return false;
    }

    console.log("‚úÖ Cl√© valide:", cleanKey);
    return true;
  }

  // Activer une license (CORRIG√â)
  public activateLicense(licenseKey: string): {
    success: boolean;
    message: string;
  } {
    if (!licenseKey || !licenseKey.trim()) {
      return {
        success: false,
        message: "Veuillez entrer une cl√© de license",
      };
    }

    let cleanKey = licenseKey.trim().toUpperCase();

    // Normaliser le format
    if (!cleanKey.startsWith("NOTHINGAI-")) {
      if (cleanKey.startsWith("NOTHINGAI")) {
        cleanKey = cleanKey.replace("NOTHINGAI", "NOTHINGAI-");
      } else {
        cleanKey = `NOTHINGAI-${cleanKey}`;
      }
    }

    console.log("üöÄ Tentative activation:", cleanKey);

    if (this.isValidLicense(cleanKey)) {
      // Incr√©menter les usages si c'est une license personnalis√©e
      this.incrementUsage(cleanKey);

      // Sauvegarder comme license active
      this.saveLicense(cleanKey);

      console.log("üéâ License activ√©e avec succ√®s:", cleanKey);
      return {
        success: true,
        message: "License activ√©e avec succ√®s !",
      };
    } else {
      console.log("‚ùå √âchec activation:", cleanKey);
      return {
        success: false,
        message: "Cl√© de license invalide, expir√©e ou √©puis√©e",
      };
    }
  }

  // Incr√©menter l'usage d'une license
  private incrementUsage(licenseKey: string): void {
    // Ne pas incr√©menter pour les licenses de base (illimit√©es)
    const isBaseLicense = this.baseLicenses.some((l) => l.key === licenseKey);
    if (isBaseLicense) {
      console.log("üìù License de base - pas d'incr√©mentation");
      return;
    }

    // Incr√©menter pour les licenses personnalis√©es
    const customLicenses = this.getCustomLicenses();
    const licenseIndex = customLicenses.findIndex((l) => l.key === licenseKey);

    if (licenseIndex !== -1) {
      customLicenses[licenseIndex].currentUsages += 1;
      this.saveCustomLicenses(customLicenses);
      console.log(
        "üìà Usage incr√©ment√©:",
        licenseKey,
        customLicenses[licenseIndex].currentUsages,
      );
    }
  }

  // Sauvegarder la license active
  private saveLicense(licenseKey: string): void {
    try {
      localStorage.setItem(this.userLicenseKey, licenseKey);
      console.log("üíæ License sauvegard√©e:", licenseKey);
    } catch (error) {
      console.warn("‚ö†Ô∏è Erreur sauvegarde:", error);
    }
  }

  // R√©cup√©rer la license sauvegard√©e
  public getSavedLicense(): string | null {
    try {
      const saved = localStorage.getItem(this.userLicenseKey);
      console.log("üìã License sauvegard√©e:", saved || "Aucune");
      return saved;
    } catch (error) {
      console.warn("‚ö†Ô∏è Erreur r√©cup√©ration:", error);
      return null;
    }
  }

  // V√©rifier si l'utilisateur a une license valide
  public hasValidLicense(): boolean {
    const saved = this.getSavedLicense();

    if (!saved) {
      console.log("‚ùå Aucune license sauvegard√©e");
      return false;
    }

    const isValid = this.isValidLicense(saved);
    console.log("üîç License sauvegard√©e valide:", isValid);

    // Si la license sauvegard√©e n'est plus valide, la supprimer
    if (!isValid) {
      console.log("üóëÔ∏è Suppression license invalide");
      this.clearLicense();
    }

    return isValid;
  }

  // Supprimer la license active
  public clearLicense(): void {
    try {
      localStorage.removeItem(this.userLicenseKey);
      console.log("üóëÔ∏è License supprim√©e");
    } catch (error) {
      console.warn("‚ö†Ô∏è Erreur suppression:", error);
    }
  }

  // Obtenir toutes les licenses pour l'admin
  public getAllLicenses(): CustomLicense[] {
    return this.getAllAvailableLicenses();
  }

  // Obtenir les d√©tails d'une license
  public getLicenseDetails(licenseKey: string): CustomLicense | null {
    const allLicenses = this.getAllAvailableLicenses();
    return allLicenses.find((l) => l.key === licenseKey.toUpperCase()) || null;
  }

  // Supprimer une license (seulement les personnalis√©es)
  public deleteLicense(licenseKey: string): boolean {
    try {
      const cleanKey = licenseKey.toUpperCase();

      // Ne pas permettre la suppression des licenses de base
      const isBaseLicense = this.baseLicenses.some((l) => l.key === cleanKey);
      if (isBaseLicense) {
        console.log("‚ö†Ô∏è Impossible de supprimer une license de base");
        return false;
      }

      const customLicenses = this.getCustomLicenses();
      const filteredLicenses = customLicenses.filter((l) => l.key !== cleanKey);

      if (filteredLicenses.length < customLicenses.length) {
        this.saveCustomLicenses(filteredLicenses);
        console.log("üóëÔ∏è License personnalis√©e supprim√©e:", cleanKey);
        return true;
      }

      return false;
    } catch (error) {
      console.error("‚ùå Erreur suppression:", error);
      return false;
    }
  }

  // Statistiques
  public getStats() {
    const allLicenses = this.getAllAvailableLicenses();
    const now = new Date();

    const active = allLicenses.filter(
      (l) =>
        l.isActive &&
        new Date(l.expiresAt) > now &&
        l.currentUsages < l.maxUsages,
    );

    const expired = allLicenses.filter((l) => new Date(l.expiresAt) <= now);

    const exhausted = allLicenses.filter((l) => l.currentUsages >= l.maxUsages);

    return {
      totalLicenses: allLicenses.length,
      baseLicenses: this.baseLicenses.length,
      customLicenses: this.getCustomLicenses().length,
      activeLicenses: active.length,
      expiredLicenses: expired.length,
      exhaustedLicenses: exhausted.length,
      hasActiveLicense: this.hasValidLicense(),
      currentLicense: this.getSavedLicense(),
      systemType: "Custom License System",
    };
  }
}

// Instance unique
export const instantLicenseManager = new InstantLicenseManager();

// Export du type pour TypeScript
export type InstantLicenseResult = {
  success: boolean;
  message: string;
};

export type { CustomLicense };
